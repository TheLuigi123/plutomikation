    <script>
        // --- DOM Elemente ---
        const gameArea = document.getElementById('game-area');
        const hero = document.getElementById('hero');
        const inventoryDisplay = document.getElementById('inventory');
        const quizModal = document.getElementById('quiz-modal');
        const quizTitle = document.getElementById('quiz-title');
        const quizQuestion = document.getElementById('quiz-question');
        const quizInputDisplay = document.getElementById('quiz-input-display');
        const quizMessage = document.getElementById('quiz-message');
        const numpadContainer = document.getElementById('numpad-container');
        const enemyElement = document.getElementById('enemy');

        // --- Audio Context & Sounds ---
        let audioCtx;
        let levelUpSound;
        const levelUpSoundBase64 = 'data:audio/mpeg;base64,SUQzBAAAAAABEVRYWFgAAAAtAAADY29tbWVudABCaWdTb3VuZEJhbmsuY29tIC8gTGliAvUMAAAAEAAAAAAAAAAAAAAAAAAAAAAA//MkxAAAANIAAAAAExBTUUzLjk4LjIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'; // Placeholder

        function initAudio() { /* ... (Audio init code as before) ... */
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                     levelUpSound = new Audio(levelUpSoundBase64);
                     levelUpSound.preload = 'auto';
                    console.log("AudioContext initialized.");
                } catch (e) { console.error("Web Audio API is not supported or initialization failed.", e); }
            }
        }
        function playTone(frequency = 440, duration = 0.1, type = 'sine', volume = 0.5) { /* ... (Audio playTone code as before) ... */
             if (!audioCtx) return;
             try {
                const oscillator = audioCtx.createOscillator(); const gainNode = audioCtx.createGain();
                oscillator.type = type; oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(volume, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
                oscillator.connect(gainNode); gainNode.connect(audioCtx.destination);
                oscillator.start(audioCtx.currentTime); oscillator.stop(audioCtx.currentTime + duration + 0.05);
            } catch (e) { console.error("Error playing tone:", e); }
        }
        // Specific sound functions (playClickSound, playCorrectSound, etc.) remain the same
        function playClickSound() { playTone(880, 0.05, 'triangle', 0.3); }
        function playInteractSound() { playTone(660, 0.08, 'sine', 0.4); }
        function playCorrectSound() { playTone(523.25, 0.1, 'sine', 0.5); setTimeout(() => playTone(659.25, 0.15, 'sine', 0.5), 100); }
        function playWrongSound() { playTone(349.23, 0.15, 'square', 0.4); setTimeout(() => playTone(261.63, 0.2, 'square', 0.4), 150); }
        function playCollectSound() { playTone(783.99, 0.08, 'triangle', 0.6); setTimeout(() => playTone(1046.50, 0.08, 'triangle', 0.6), 80); setTimeout(() => playTone(1318.51, 0.1, 'triangle', 0.6), 160); }
        function playFreezeSound() { playTone(440, 0.3, 'sawtooth', 0.4); }
        function playUnfreezeSound() { playTone(587.33, 0.2, 'sine', 0.4); }
        function playEnemySpawnSound() { playTone(110, 0.3, 'sawtooth', 0.5); }
        function playEnemyHitSound() { playTone(220, 0.2, 'square', 0.6); }
        function playLevelUpJingle() {
             if (levelUpSound && audioCtx) {
                 levelUpSound.play().catch(e => console.error("Error playing level up sound:", e));
             } else { playTone(523, 0.1); setTimeout(() => playTone(783, 0.1), 100); setTimeout(() => playTone(1046, 0.2), 200); }
         }

        // --- Spielzustand ---
        let currentLevel = 1;
        let flowersCollected = 0;
        let flowers = [];
        let activeItem = null;
        let activeItemType = null;
        let currentQuestions = [];
        let currentQuestionIndex = 0;
        let heroIsMoving = false;

        // --- Konfiguration ---
        const NUM_FLOWERS_PER_LEVEL = 5;
        const NUM_QUESTIONS_PER_ITEM = 5;
        const flowerColors = [
            { bg: '#f48fb1', border: '#ad1457' }, { bg: '#90caf9', border: '#1e88e5' },
            { bg: '#ffe082', border: '#ffab00' }, { bg: '#a5d6a7', border: '#388e3c' },
            { bg: '#b39ddb', border: '#5e35b1' }
        ];

        // --- Feind Konfiguration & Zustand ---
        // ** MODIFIED ** Initial speed doubled by doubling step size
        const BASE_ENEMY_STEP_SIZE = 10; // Was 5, now doubled for initial speed
        const BASE_ENEMY_MOVE_INTERVAL = 200; // Interval remains the same initially
        const ENEMY_RANDOM_FACTOR = 4;
        const ENEMY_FREEZE_DURATION = 10000;
        const ENEMY_SPAWN_DELAY = 5000;

        // Use BASE values for initial level 1 speed
        let currentEnemyStepSize = BASE_ENEMY_STEP_SIZE;
        let currentEnemyMoveInterval = BASE_ENEMY_MOVE_INTERVAL; // Keep interval constant for now, adjust step size for speed

        let enemyData = { element: enemyElement, position: { x: -100, y: -100 }, active: false, frozen: false, freezeTimeoutId: null, moveIntervalId: null };

        // --- Initialisierung ---
        function initGame() {
            // Set initial speed values correctly before starting
            currentEnemyStepSize = BASE_ENEMY_STEP_SIZE;
            currentEnemyMoveInterval = BASE_ENEMY_MOVE_INTERVAL;

            updateInventory();
            updateTitle();
            setupLevel();
            // Event Listener
            gameArea.addEventListener('click', handleFirstClick);
            hero.addEventListener('transitionend', onHeroMovementEnd);
            numpadContainer.addEventListener('click', handleNumpadClick);
            // Feind-Logik starten
            startEnemyLogic();
        }

        // --- Spezieller Handler für den ersten Klick ---
        function handleFirstClick(event) { /* ... (Audio init code as before) ... */
            initAudio();
            handleGameAreaClick(event);
            gameArea.removeEventListener('click', handleFirstClick);
            gameArea.addEventListener('click', handleGameAreaClick);
        }

        // --- Level Management ---
        function setupLevel() { clearOldFlowers(); createFlowers(); }

        function startNewLevel() {
            currentLevel++;
            updateTitle();
            playLevelUpJingle();

            // ** MODIFIED ** Increase speed by 20% based on previous level's step size
            // Calculate 20% increase from the speed of the level just completed
            currentEnemyStepSize = currentEnemyStepSize * 1.20;

            // Optional: You could also slightly decrease the interval, but increasing step size
            // is the primary way to increase speed (pixels per interval).
            // Let's keep interval constant for simplicity unless needed.
            // currentEnemyMoveInterval = Math.max(50, currentEnemyMoveInterval * 0.95); // Example: 5% faster interval

            console.log(`Starte Level ${currentLevel}. Feind Schrittgröße: ${currentEnemyStepSize.toFixed(2)}, Intervall: ${currentEnemyMoveInterval}`);

            setTimeout(() => {
                 setupLevel();
                 if (enemyData.active) { despawnEnemy(); }
                 spawnEnemy(); // Spawns with the new speed settings
            }, 1500);
        }
        function updateTitle() { document.title = `Koalas Multiplikations-Abenteuer Lvl. ${currentLevel}`; }

        // --- Blumen Management ---
        function clearOldFlowers() { /* ... (Blumen clear code as before) ... */ flowers.forEach(flower => { if (flower.element && flower.element.parentNode === gameArea) { gameArea.removeChild(flower.element); } }); flowers = []; }
        function createFlowers() { /* ... (Blumen create code as before) ... */
            const areaRect = gameArea.getBoundingClientRect();
            const colors = flowerColors[(currentLevel - 1) % flowerColors.length];
            for (let i = 0; i < NUM_FLOWERS_PER_LEVEL; i++) {
                const flowerElement = document.createElement('div'); flowerElement.classList.add('flower'); flowerElement.id = `flower-${currentLevel}-${i}`;
                flowerElement.style.backgroundColor = colors.bg; flowerElement.style.borderColor = colors.border;
                let pos; let tooClose; let attempts = 0;
                do {
                    tooClose = false; pos = getRandomPosition(areaRect, 60);
                    for (const flw of flowers) { const dist = Math.sqrt(Math.pow(pos.x - flw.position.x, 2) + Math.pow(pos.y - flw.position.y, 2)); if (dist < 50) { tooClose = true; break; } }
                    attempts++;
                } while (tooClose && attempts < 100);
                if (attempts >= 100) { console.warn("Konnte keine geeignete Position für Blume finden."); }
                flowerElement.style.left = `${pos.x}px`; flowerElement.style.top = `${pos.y}px`; gameArea.appendChild(flowerElement);
                flowers.push({ id: flowerElement.id, element: flowerElement, collected: false, position: pos });
            }
        }

        // --- Heldenbewegung & Klick-Handling ---
        function handleGameAreaClick(event) { /* ... (Klick handler code as before) ... */
             if (heroIsMoving || quizModal.style.display === 'block') { return; }
             playClickSound(); const areaRect = gameArea.getBoundingClientRect();
             const targetX = event.clientX - areaRect.left; const targetY = event.clientY - areaRect.top;
             moveHero(targetX, targetY);
         }
        function moveHero(targetX, targetY) { /* ... (moveHero code as before) ... */
             heroIsMoving = true; const heroRect = hero.getBoundingClientRect(); const heroWidth = hero.offsetWidth || 50; const heroHeight = hero.offsetHeight || 50;
             let finalX = targetX - heroWidth / 2; let finalY = targetY - heroHeight / 2;
             const areaRect = gameArea.getBoundingClientRect();
             finalX = Math.max(0, Math.min(finalX, areaRect.width - heroWidth)); finalY = Math.max(0, Math.min(finalY, areaRect.height - heroHeight));
             hero.style.left = `${finalX}px`; hero.style.top = `${finalY}px`;
         }
        function onHeroMovementEnd() { heroIsMoving = false; checkCollision(); }

        // --- Kollisionserkennung ---
        function checkCollision() { /* ... (Kollisions code as before) ... */
             if (enemyData.active && !enemyData.frozen && quizModal.style.display !== 'block') {
                const heroRect = hero.getBoundingClientRect(); const enemyRect = enemyData.element.getBoundingClientRect();
                 if (checkRectOverlap(heroRect, enemyRect)) { playEnemyHitSound(); triggerEnemyQuiz(); return; }
            }
            if (heroIsMoving || quizModal.style.display === 'block') return;
            const heroRect = hero.getBoundingClientRect();
            for (let flower of flowers) {
                if (!flower.collected) {
                    const flowerRect = flower.element.getBoundingClientRect();
                    if (checkRectOverlap(heroRect, flowerRect)) { playInteractSound(); activeItem = flower; activeItemType = 'flower'; startQuiz(); return; }
                }
            }
        }
        function checkRectOverlap(rect1, rect2) { /* ... (unverändert) ... */ return !( rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom ); }

        // --- NumPad-Logik ---
        function handleNumpadClick(event) { /* ... (Numpad code as before) ... */
            const target = event.target; if (target.tagName !== 'BUTTON') return;
            playClickSound();
            if (target.hasAttribute('data-digit')) { const digit = target.getAttribute('data-digit'); if (quizInputDisplay.textContent.length < 4) { quizInputDisplay.textContent += digit; } }
            else if (target.id === 'numpad-clear') { quizInputDisplay.textContent = ''; }
            else if (target.id === 'numpad-submit') { checkAnswer(); }
        }

        // --- Quiz-Logik ---
        function startQuiz() { /* ... (Quiz start code as before) ... */ quizTitle.textContent = "Blumen-Aufgabe!"; currentQuestions = generateQuestions(NUM_QUESTIONS_PER_ITEM); currentQuestionIndex = 0; quizMessage.textContent = ''; quizMessage.className = ''; quizInputDisplay.textContent = ''; displayQuestion(); quizModal.style.display = 'block'; }
        function triggerEnemyQuiz() { /* ... (Enemy quiz trigger code as before) ... */ if (!enemyData.active || enemyData.frozen) return; if (enemyData.moveIntervalId) { clearInterval(enemyData.moveIntervalId); enemyData.moveIntervalId = null; } activeItem = enemyData; activeItemType = 'enemy'; quizTitle.textContent = "Monster-Aufgabe!"; currentQuestions = generateQuestions(NUM_QUESTIONS_PER_ITEM); currentQuestionIndex = 0; quizMessage.textContent = ''; quizMessage.className = ''; quizInputDisplay.textContent = ''; displayQuestion(); quizModal.style.display = 'block'; }
        function generateQuestions(count) { /* ... (unverändert) ... */ const questions = []; for (let i = 0; i < count; i++) { const num1 = Math.floor(Math.random() * 10) + 1; const num2 = Math.floor(Math.random() * 10) + 1; questions.push({ text: `${num1} x ${num2} = ?`, answer: num1 * num2 }); } return questions; }
        function displayQuestion() { /* ... (unverändert) ... */ if (currentQuestionIndex < currentQuestions.length) { quizQuestion.textContent = currentQuestions[currentQuestionIndex].text; } else { console.error("Versucht, Frage außerhalb des Bereichs anzuzeigen."); } }
        function checkAnswer() { /* ... (checkAnswer code as before, includes sound calls) ... */
            const userAnswerText = quizInputDisplay.textContent;
            if (userAnswerText === '') { quizMessage.textContent = "Bitte gib eine Antwort über die Tasten ein!"; quizMessage.className = 'incorrect'; return; }
            const userAnswer = parseInt(userAnswerText, 10); const correctAnswer = currentQuestions[currentQuestionIndex].answer;
            if (isNaN(userAnswer)) { quizMessage.textContent = "Ungültige Eingabe."; quizMessage.className = 'incorrect'; quizInputDisplay.textContent = ''; return; }
            if (userAnswer === correctAnswer) {
                playCorrectSound(); quizMessage.textContent = "Richtig!"; quizMessage.className = 'correct'; currentQuestionIndex++;
                setTimeout(() => { if (currentQuestionIndex >= currentQuestions.length) { handleQuizSuccess(); } else { quizMessage.textContent = ''; quizMessage.className = ''; quizInputDisplay.textContent = ''; displayQuestion(); } }, 800);
            } else {
                playWrongSound(); quizMessage.textContent = `Leider falsch. Die richtige Antwort war ${correctAnswer}. Versuche die Frage erneut!`;
                quizMessage.className = 'incorrect'; quizInputDisplay.textContent = '';
            }
        }
        function handleQuizSuccess() { /* ... (handleQuizSuccess code as before, includes sound calls) ... */
            quizModal.style.display = 'none';
            if (activeItemType === 'flower') {
                playCollectSound(); activeItem.element.classList.add('hidden'); activeItem.collected = true; flowersCollected++; updateInventory();
                 if (flowers.every(f => f.collected)) {
                     setTimeout(() => { alert(`Super! Level ${currentLevel} geschafft! ${flowersCollected} Blumen insgesamt gesammelt.`); startNewLevel(); }, 300);
                }
            } else if (activeItemType === 'enemy') {
                 playFreezeSound(); freezeEnemy();
            }
            activeItem = null; activeItemType = null;
        }

        // --- Inventar aktualisieren ---
        function updateInventory() { /* ... (unverändert) ... */ inventoryDisplay.textContent = `Blumen: ${flowersCollected}`; }

        // --- Feind-Logik ---
        function startEnemyLogic() { setTimeout(spawnEnemy, ENEMY_SPAWN_DELAY); }
        function spawnEnemy() { /* ... (spawnEnemy code as before, uses current speed vars) ... */
            if (enemyData.active) return; playEnemySpawnSound(); const areaRect = gameArea.getBoundingClientRect(); const edge = Math.floor(Math.random() * 4); const enemySize = 40; let startX, startY;
            switch (edge) { case 0: startX = Math.random()*(areaRect.width-enemySize); startY = -enemySize; break; case 1: startX = areaRect.width; startY = Math.random()*(areaRect.height-enemySize); break; case 2: startX = Math.random()*(areaRect.width-enemySize); startY = areaRect.height; break; case 3: startX = -enemySize; startY = Math.random()*(areaRect.height-enemySize); break; }
            enemyData.position = { x: startX, y: startY }; enemyData.element.style.left = `${startX}px`; enemyData.element.style.top = `${startY}px`;
            enemyData.element.classList.remove('hidden', 'enemy-frozen'); enemyData.active = true; enemyData.frozen = false;
            if (enemyData.moveIntervalId) clearInterval(enemyData.moveIntervalId);
            enemyData.moveIntervalId = setInterval(moveEnemy, currentEnemyMoveInterval); // Uses current interval
            console.log(`Feind gespawnt (Level ${currentLevel})`);
        }
        function despawnEnemy() { /* ... (unverändert) ... */ if (!enemyData.active) return; if (enemyData.moveIntervalId) clearInterval(enemyData.moveIntervalId); if (enemyData.freezeTimeoutId) clearTimeout(enemyData.freezeTimeoutId); enemyData.element.classList.add('hidden'); enemyData.active = false; enemyData.frozen = false; enemyData.moveIntervalId = null; enemyData.freezeTimeoutId = null; enemyData.position = { x: -100, y: -100 }; console.log("Feind despawned"); }
        function moveEnemy() { /* ... (moveEnemy code as before, uses current speed vars) ... */
             if (quizModal.style.display === 'block' || !enemyData.active || enemyData.frozen) { return; }
             const enemyX = enemyData.position.x; const enemyY = enemyData.position.y; const heroRect = hero.getBoundingClientRect(); const areaRect = gameArea.getBoundingClientRect();
             const heroCenterX = (heroRect.left - areaRect.left) + heroRect.width / 2; const heroCenterY = (heroRect.top - areaRect.top) + heroRect.height / 2;
             const dx = heroCenterX - (enemyX + enemyData.element.offsetWidth / 2); const dy = heroCenterY - (enemyY + enemyData.element.offsetHeight / 2); const distance = Math.sqrt(dx * dx + dy * dy);
             if (distance < 5) { checkCollision(); return; }
             const normDx = dx / distance; const normDy = dy / distance;
             let stepX = normDx * currentEnemyStepSize; let stepY = normDy * currentEnemyStepSize; // Uses current step size
             stepX += (Math.random() - 0.5) * 2 * ENEMY_RANDOM_FACTOR; stepY += (Math.random() - 0.5) * 2 * ENEMY_RANDOM_FACTOR;
             let newX = enemyX + stepX; let newY = enemyY + stepY;
             const enemyWidth = enemyData.element.offsetWidth || 40; const enemyHeight = enemyData.element.offsetHeight || 40;
             newX = Math.max(0, Math.min(newX, areaRect.width - enemyWidth)); newY = Math.max(0, Math.min(newY, areaRect.height - enemyHeight));
             enemyData.position = { x: newX, y: newY }; enemyData.element.style.left = `${newX}px`; enemyData.element.style.top = `${newY}px`; checkCollision();
         }
        function freezeEnemy() { /* ... (freezeEnemy code as before) ... */ if (!enemyData.active) return; if (enemyData.moveIntervalId) { clearInterval(enemyData.moveIntervalId); enemyData.moveIntervalId = null; } if (enemyData.freezeTimeoutId) { clearTimeout(enemyData.freezeTimeoutId); } enemyData.frozen = true; enemyData.element.classList.add('enemy-frozen'); enemyData.freezeTimeoutId = setTimeout(unfreezeEnemy, ENEMY_FREEZE_DURATION); }
        function unfreezeEnemy() { /* ... (unfreezeEnemy code as before, uses current speed vars) ... */
             if (!enemyData.active || !enemyData.frozen) return; playUnfreezeSound(); enemyData.frozen = false; enemyData.element.classList.remove('enemy-frozen'); enemyData.freezeTimeoutId = null;
             if (quizModal.style.display !== 'block') { if (enemyData.moveIntervalId) clearInterval(enemyData.moveIntervalId); enemyData.moveIntervalId = setInterval(moveEnemy, currentEnemyMoveInterval); } // Uses current interval
         }

        // Hilfsfunktion für zufällige Position
        function getRandomPosition(bounds, margin) { /* ... (unverändert) ... */ const width = bounds.width || window.innerWidth; const height = bounds.height || window.innerHeight; const objSize = 40; const x = Math.random() * (width - margin * 2 - objSize) + margin; const y = Math.random() * (height - margin * 2 - objSize) + margin; return { x, y }; }

        // --- Spielstart ---
        document.addEventListener('DOMContentLoaded', initGame);

    </script>
